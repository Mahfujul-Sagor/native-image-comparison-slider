"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compile;
var _path = _interopRequireDefault(require("path"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _kleur = _interopRequireDefault(require("kleur"));
var babel = _interopRequireWildcard(require("@babel/core"));
var _glob = _interopRequireDefault(require("glob"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const sourceExt = /\.([cm])?[jt]sx?$/;
async function compile({
  root,
  source,
  output,
  esm = false,
  babelrc = false,
  configFile = false,
  exclude,
  modules,
  copyFlow,
  sourceMaps = true,
  report
}) {
  const files = _glob.default.sync('**/*', {
    cwd: source,
    absolute: true,
    nodir: true,
    ignore: exclude
  });
  report.info(`Compiling ${_kleur.default.blue(String(files.length))} files in ${_kleur.default.blue(_path.default.relative(root, source))} with ${_kleur.default.blue('babel')}`);
  const pkg = JSON.parse(await _fsExtra.default.readFile(_path.default.join(root, 'package.json'), 'utf-8'));
  if (copyFlow) {
    if (!Object.keys(pkg.devDependencies || {}).includes('flow-bin')) {
      report.warn(`The ${_kleur.default.blue('copyFlow')} option was specified, but couldn't find ${_kleur.default.blue('flow-bin')} in ${_kleur.default.blue('package.json')}.\nIf the project is using ${_kleur.default.blue('flow')}, then make sure you have added ${_kleur.default.blue('flow-bin')} to your ${_kleur.default.blue('devDependencies')}, otherwise remove the ${_kleur.default.blue('copyFlow')} option.`);
    }
  }
  await _fsExtra.default.mkdirp(output);
  await _fsExtra.default.writeJSON(_path.default.join(output, 'package.json'), {
    type: modules === 'commonjs' ? 'commonjs' : 'module'
  });
  await Promise.all(files.map(async filepath => {
    const outputFilename = _path.default.join(output, _path.default.relative(source, filepath)).replace(sourceExt, '.$1js');
    await _fsExtra.default.mkdirp(_path.default.dirname(outputFilename));
    if (!sourceExt.test(filepath)) {
      // Copy files which aren't source code
      _fsExtra.default.copy(filepath, outputFilename);
      return;
    }
    const content = await _fsExtra.default.readFile(filepath, 'utf-8');
    const result = await babel.transformAsync(content, {
      cwd: root,
      babelrc: babelrc,
      configFile: configFile,
      sourceMaps,
      sourceRoot: _path.default.relative(_path.default.dirname(outputFilename), source),
      sourceFileName: _path.default.relative(source, filepath),
      filename: filepath,
      ...(babelrc || configFile ? null : {
        presets: [[require.resolve('../../babel-preset'), {
          modules:
          // If a file is explicitly marked as ESM, then preserve the syntax
          /\.m[jt]s$/.test(filepath) ? 'preserve' : modules,
          esm
        }]]
      })
    });
    if (result == null) {
      throw new Error('Output code was null');
    }
    let code = result.code;
    if (sourceMaps && result.map) {
      const mapFilename = outputFilename + '.map';
      code += '\n//# sourceMappingURL=' + _path.default.basename(mapFilename);

      // Don't inline the source code, it can be retrieved from the source file
      result.map.sourcesContent = undefined;
      await _fsExtra.default.writeJSON(mapFilename, result.map);
    }
    await _fsExtra.default.writeFile(outputFilename, code);
    if (copyFlow) {
      _fsExtra.default.copy(filepath, outputFilename + '.flow');
    }
  }));
  report.success(`Wrote files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
  const getGeneratedEntryPath = async () => {
    if (pkg.source) {
      for (const ext of ['.js', '.cjs', '.mjs']) {
        const indexName =
        // The source field may not have an extension, so we add it instead of replacing directly
        _path.default.basename(pkg.source).replace(sourceExt, '') + ext;
        const potentialPath = _path.default.join(output, _path.default.dirname(_path.default.relative(source, _path.default.join(root, pkg.source))), indexName);
        if (await _fsExtra.default.pathExists(potentialPath)) {
          return _path.default.relative(root, potentialPath);
        }
      }
    }
    return null;
  };
  const fields = modules === 'commonjs' ? [{
    name: 'main',
    value: pkg.main
  }] : [{
    name: 'module',
    value: pkg.module
  }];
  if (esm) {
    if (modules === 'commonjs') {
      fields.push(typeof pkg.exports?.['.']?.require === 'string' ? {
        name: "exports['.'].require",
        value: pkg.exports?.['.']?.require
      } : {
        name: "exports['.'].require.default",
        value: pkg.exports?.['.']?.require?.default
      });
    } else {
      fields.push(typeof pkg.exports?.['.']?.import === 'string' ? {
        name: "exports['.'].import",
        value: pkg.exports?.['.']?.import
      } : {
        name: "exports['.'].import.default",
        value: pkg.exports?.['.']?.import?.default
      });
    }
  } else {
    if (modules === 'commonjs' && pkg.exports?.['.']?.require) {
      report.warn(`The ${_kleur.default.blue('esm')} option is disabled, but the ${_kleur.default.blue("exports['.'].require")} field is set in ${_kleur.default.blue('package.json')}. This is likely a mistake.`);
    } else if (modules === 'preserve' && pkg.exports?.['.']?.import) {
      report.warn(`The ${_kleur.default.blue('esm')} option is disabled, but the ${_kleur.default.blue("exports['.'].import")} field is set in ${_kleur.default.blue('package.json')}. This is likely a mistake.`);
    }
  }
  if (fields.some(field => field.value)) {
    await Promise.all(fields.map(async ({
      name,
      value
    }) => {
      if (!value) {
        return;
      }
      if (name.startsWith('exports') && value && !/^\.\//.test(value)) {
        report.error(`The ${_kleur.default.blue(name)} field in ${_kleur.default.blue(`package.json`)} should be a relative path starting with ${_kleur.default.blue('./')}. Found: ${_kleur.default.blue(value)}`);
        throw new Error(`Found incorrect path in '${name}' field.`);
      }
      try {
        require.resolve(_path.default.join(root, value));
      } catch (e) {
        if (e != null && typeof e === 'object' && 'code' in e && e.code === 'MODULE_NOT_FOUND') {
          const generatedEntryPath = await getGeneratedEntryPath();
          if (!generatedEntryPath) {
            report.warn(`Failed to detect the entry point for the generated files. Make sure you have a valid ${_kleur.default.blue('source')} field in your ${_kleur.default.blue('package.json')}.`);
          }
          report.error(`The ${_kleur.default.blue(name)} field in ${_kleur.default.blue('package.json')} points to a non-existent file: ${_kleur.default.blue(value)}.\nVerify the path points to the correct file under ${_kleur.default.blue(_path.default.relative(root, output))}${generatedEntryPath ? ` (found ${_kleur.default.blue(generatedEntryPath)}).` : '.'}`);
          throw new Error(`Found incorrect path in '${name}' field.`);
        }
        throw e;
      }
    }));
  } else {
    const generatedEntryPath = await getGeneratedEntryPath();
    report.warn(`No ${fields.map(field => _kleur.default.blue(field.name)).join(' or ')} field found in ${_kleur.default.blue('package.json')}. Consider ${generatedEntryPath ? `pointing to ${_kleur.default.blue(generatedEntryPath)}` : `adding ${fields.length > 1 ? 'them' : 'it'}`} so that consumers of your package can import your package.`);
  }
}
//# sourceMappingURL=compile.js.map